// Code generated by counterfeiter. DO NOT EDIT.
package kubernetesfakes

import (
	"sync"

	clouddriver "github.com/homedepot/go-clouddriver/pkg"
	"github.com/homedepot/go-clouddriver/pkg/kubernetes"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/rest"
)

type FakeController struct {
	NewClientStub        func(*rest.Config) (kubernetes.Client, error)
	newClientMutex       sync.RWMutex
	newClientArgsForCall []struct {
		arg1 *rest.Config
	}
	newClientReturns struct {
		result1 kubernetes.Client
		result2 error
	}
	newClientReturnsOnCall map[int]struct {
		result1 kubernetes.Client
		result2 error
	}
	ToUnstructuredStub        func(map[string]interface{}) (*unstructured.Unstructured, error)
	toUnstructuredMutex       sync.RWMutex
	toUnstructuredArgsForCall []struct {
		arg1 map[string]interface{}
	}
	toUnstructuredReturns struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	toUnstructuredReturnsOnCall map[int]struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	AddSpinnakerAnnotationsStub        func(u *unstructured.Unstructured, application string) error
	addSpinnakerAnnotationsMutex       sync.RWMutex
	addSpinnakerAnnotationsArgsForCall []struct {
		u           *unstructured.Unstructured
		application string
	}
	addSpinnakerAnnotationsReturns struct {
		result1 error
	}
	addSpinnakerAnnotationsReturnsOnCall map[int]struct {
		result1 error
	}
	AddSpinnakerLabelsStub        func(u *unstructured.Unstructured, application string) error
	addSpinnakerLabelsMutex       sync.RWMutex
	addSpinnakerLabelsArgsForCall []struct {
		u           *unstructured.Unstructured
		application string
	}
	addSpinnakerLabelsReturns struct {
		result1 error
	}
	addSpinnakerLabelsReturnsOnCall map[int]struct {
		result1 error
	}
	SortManifestsStub        func([]map[string]interface{}) ([]map[string]interface{}, error)
	sortManifestsMutex       sync.RWMutex
	sortManifestsArgsForCall []struct {
		arg1 []map[string]interface{}
	}
	sortManifestsReturns struct {
		result1 []map[string]interface{}
		result2 error
	}
	sortManifestsReturnsOnCall map[int]struct {
		result1 []map[string]interface{}
		result2 error
	}
	AddSpinnakerVersionAnnotationsStub        func(u *unstructured.Unstructured, version kubernetes.SpinnakerVersion) error
	addSpinnakerVersionAnnotationsMutex       sync.RWMutex
	addSpinnakerVersionAnnotationsArgsForCall []struct {
		u       *unstructured.Unstructured
		version kubernetes.SpinnakerVersion
	}
	addSpinnakerVersionAnnotationsReturns struct {
		result1 error
	}
	addSpinnakerVersionAnnotationsReturnsOnCall map[int]struct {
		result1 error
	}
	AddSpinnakerVersionLabelsStub        func(u *unstructured.Unstructured, version kubernetes.SpinnakerVersion) error
	addSpinnakerVersionLabelsMutex       sync.RWMutex
	addSpinnakerVersionLabelsArgsForCall []struct {
		u       *unstructured.Unstructured
		version kubernetes.SpinnakerVersion
	}
	addSpinnakerVersionLabelsReturns struct {
		result1 error
	}
	addSpinnakerVersionLabelsReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentVersionStub        func(ul *unstructured.UnstructuredList, kind, name string) string
	getCurrentVersionMutex       sync.RWMutex
	getCurrentVersionArgsForCall []struct {
		ul   *unstructured.UnstructuredList
		kind string
		name string
	}
	getCurrentVersionReturns struct {
		result1 string
	}
	getCurrentVersionReturnsOnCall map[int]struct {
		result1 string
	}
	IsVersionedStub        func(u *unstructured.Unstructured) bool
	isVersionedMutex       sync.RWMutex
	isVersionedArgsForCall []struct {
		u *unstructured.Unstructured
	}
	isVersionedReturns struct {
		result1 bool
	}
	isVersionedReturnsOnCall map[int]struct {
		result1 bool
	}
	IncrementVersionStub        func(currentVersion string) kubernetes.SpinnakerVersion
	incrementVersionMutex       sync.RWMutex
	incrementVersionArgsForCall []struct {
		currentVersion string
	}
	incrementVersionReturns struct {
		result1 kubernetes.SpinnakerVersion
	}
	incrementVersionReturnsOnCall map[int]struct {
		result1 kubernetes.SpinnakerVersion
	}
	VersionVolumesStub        func(u *unstructured.Unstructured, requiredArtifacts []clouddriver.TaskCreatedArtifact) error
	versionVolumesMutex       sync.RWMutex
	versionVolumesArgsForCall []struct {
		u                 *unstructured.Unstructured
		requiredArtifacts []clouddriver.TaskCreatedArtifact
	}
	versionVolumesReturns struct {
		result1 error
	}
	versionVolumesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeController) NewClient(arg1 *rest.Config) (kubernetes.Client, error) {
	fake.newClientMutex.Lock()
	ret, specificReturn := fake.newClientReturnsOnCall[len(fake.newClientArgsForCall)]
	fake.newClientArgsForCall = append(fake.newClientArgsForCall, struct {
		arg1 *rest.Config
	}{arg1})
	fake.recordInvocation("NewClient", []interface{}{arg1})
	fake.newClientMutex.Unlock()
	if fake.NewClientStub != nil {
		return fake.NewClientStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.newClientReturns.result1, fake.newClientReturns.result2
}

func (fake *FakeController) NewClientCallCount() int {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	return len(fake.newClientArgsForCall)
}

func (fake *FakeController) NewClientArgsForCall(i int) *rest.Config {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	return fake.newClientArgsForCall[i].arg1
}

func (fake *FakeController) NewClientReturns(result1 kubernetes.Client, result2 error) {
	fake.NewClientStub = nil
	fake.newClientReturns = struct {
		result1 kubernetes.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeController) NewClientReturnsOnCall(i int, result1 kubernetes.Client, result2 error) {
	fake.NewClientStub = nil
	if fake.newClientReturnsOnCall == nil {
		fake.newClientReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Client
			result2 error
		})
	}
	fake.newClientReturnsOnCall[i] = struct {
		result1 kubernetes.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeController) ToUnstructured(arg1 map[string]interface{}) (*unstructured.Unstructured, error) {
	fake.toUnstructuredMutex.Lock()
	ret, specificReturn := fake.toUnstructuredReturnsOnCall[len(fake.toUnstructuredArgsForCall)]
	fake.toUnstructuredArgsForCall = append(fake.toUnstructuredArgsForCall, struct {
		arg1 map[string]interface{}
	}{arg1})
	fake.recordInvocation("ToUnstructured", []interface{}{arg1})
	fake.toUnstructuredMutex.Unlock()
	if fake.ToUnstructuredStub != nil {
		return fake.ToUnstructuredStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.toUnstructuredReturns.result1, fake.toUnstructuredReturns.result2
}

func (fake *FakeController) ToUnstructuredCallCount() int {
	fake.toUnstructuredMutex.RLock()
	defer fake.toUnstructuredMutex.RUnlock()
	return len(fake.toUnstructuredArgsForCall)
}

func (fake *FakeController) ToUnstructuredArgsForCall(i int) map[string]interface{} {
	fake.toUnstructuredMutex.RLock()
	defer fake.toUnstructuredMutex.RUnlock()
	return fake.toUnstructuredArgsForCall[i].arg1
}

func (fake *FakeController) ToUnstructuredReturns(result1 *unstructured.Unstructured, result2 error) {
	fake.ToUnstructuredStub = nil
	fake.toUnstructuredReturns = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeController) ToUnstructuredReturnsOnCall(i int, result1 *unstructured.Unstructured, result2 error) {
	fake.ToUnstructuredStub = nil
	if fake.toUnstructuredReturnsOnCall == nil {
		fake.toUnstructuredReturnsOnCall = make(map[int]struct {
			result1 *unstructured.Unstructured
			result2 error
		})
	}
	fake.toUnstructuredReturnsOnCall[i] = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeController) AddSpinnakerAnnotations(u *unstructured.Unstructured, application string) error {
	fake.addSpinnakerAnnotationsMutex.Lock()
	ret, specificReturn := fake.addSpinnakerAnnotationsReturnsOnCall[len(fake.addSpinnakerAnnotationsArgsForCall)]
	fake.addSpinnakerAnnotationsArgsForCall = append(fake.addSpinnakerAnnotationsArgsForCall, struct {
		u           *unstructured.Unstructured
		application string
	}{u, application})
	fake.recordInvocation("AddSpinnakerAnnotations", []interface{}{u, application})
	fake.addSpinnakerAnnotationsMutex.Unlock()
	if fake.AddSpinnakerAnnotationsStub != nil {
		return fake.AddSpinnakerAnnotationsStub(u, application)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addSpinnakerAnnotationsReturns.result1
}

func (fake *FakeController) AddSpinnakerAnnotationsCallCount() int {
	fake.addSpinnakerAnnotationsMutex.RLock()
	defer fake.addSpinnakerAnnotationsMutex.RUnlock()
	return len(fake.addSpinnakerAnnotationsArgsForCall)
}

func (fake *FakeController) AddSpinnakerAnnotationsArgsForCall(i int) (*unstructured.Unstructured, string) {
	fake.addSpinnakerAnnotationsMutex.RLock()
	defer fake.addSpinnakerAnnotationsMutex.RUnlock()
	return fake.addSpinnakerAnnotationsArgsForCall[i].u, fake.addSpinnakerAnnotationsArgsForCall[i].application
}

func (fake *FakeController) AddSpinnakerAnnotationsReturns(result1 error) {
	fake.AddSpinnakerAnnotationsStub = nil
	fake.addSpinnakerAnnotationsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerAnnotationsReturnsOnCall(i int, result1 error) {
	fake.AddSpinnakerAnnotationsStub = nil
	if fake.addSpinnakerAnnotationsReturnsOnCall == nil {
		fake.addSpinnakerAnnotationsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpinnakerAnnotationsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerLabels(u *unstructured.Unstructured, application string) error {
	fake.addSpinnakerLabelsMutex.Lock()
	ret, specificReturn := fake.addSpinnakerLabelsReturnsOnCall[len(fake.addSpinnakerLabelsArgsForCall)]
	fake.addSpinnakerLabelsArgsForCall = append(fake.addSpinnakerLabelsArgsForCall, struct {
		u           *unstructured.Unstructured
		application string
	}{u, application})
	fake.recordInvocation("AddSpinnakerLabels", []interface{}{u, application})
	fake.addSpinnakerLabelsMutex.Unlock()
	if fake.AddSpinnakerLabelsStub != nil {
		return fake.AddSpinnakerLabelsStub(u, application)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addSpinnakerLabelsReturns.result1
}

func (fake *FakeController) AddSpinnakerLabelsCallCount() int {
	fake.addSpinnakerLabelsMutex.RLock()
	defer fake.addSpinnakerLabelsMutex.RUnlock()
	return len(fake.addSpinnakerLabelsArgsForCall)
}

func (fake *FakeController) AddSpinnakerLabelsArgsForCall(i int) (*unstructured.Unstructured, string) {
	fake.addSpinnakerLabelsMutex.RLock()
	defer fake.addSpinnakerLabelsMutex.RUnlock()
	return fake.addSpinnakerLabelsArgsForCall[i].u, fake.addSpinnakerLabelsArgsForCall[i].application
}

func (fake *FakeController) AddSpinnakerLabelsReturns(result1 error) {
	fake.AddSpinnakerLabelsStub = nil
	fake.addSpinnakerLabelsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerLabelsReturnsOnCall(i int, result1 error) {
	fake.AddSpinnakerLabelsStub = nil
	if fake.addSpinnakerLabelsReturnsOnCall == nil {
		fake.addSpinnakerLabelsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpinnakerLabelsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SortManifests(arg1 []map[string]interface{}) ([]map[string]interface{}, error) {
	var arg1Copy []map[string]interface{}
	if arg1 != nil {
		arg1Copy = make([]map[string]interface{}, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sortManifestsMutex.Lock()
	ret, specificReturn := fake.sortManifestsReturnsOnCall[len(fake.sortManifestsArgsForCall)]
	fake.sortManifestsArgsForCall = append(fake.sortManifestsArgsForCall, struct {
		arg1 []map[string]interface{}
	}{arg1Copy})
	fake.recordInvocation("SortManifests", []interface{}{arg1Copy})
	fake.sortManifestsMutex.Unlock()
	if fake.SortManifestsStub != nil {
		return fake.SortManifestsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sortManifestsReturns.result1, fake.sortManifestsReturns.result2
}

func (fake *FakeController) SortManifestsCallCount() int {
	fake.sortManifestsMutex.RLock()
	defer fake.sortManifestsMutex.RUnlock()
	return len(fake.sortManifestsArgsForCall)
}

func (fake *FakeController) SortManifestsArgsForCall(i int) []map[string]interface{} {
	fake.sortManifestsMutex.RLock()
	defer fake.sortManifestsMutex.RUnlock()
	return fake.sortManifestsArgsForCall[i].arg1
}

func (fake *FakeController) SortManifestsReturns(result1 []map[string]interface{}, result2 error) {
	fake.SortManifestsStub = nil
	fake.sortManifestsReturns = struct {
		result1 []map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) SortManifestsReturnsOnCall(i int, result1 []map[string]interface{}, result2 error) {
	fake.SortManifestsStub = nil
	if fake.sortManifestsReturnsOnCall == nil {
		fake.sortManifestsReturnsOnCall = make(map[int]struct {
			result1 []map[string]interface{}
			result2 error
		})
	}
	fake.sortManifestsReturnsOnCall[i] = struct {
		result1 []map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) AddSpinnakerVersionAnnotations(u *unstructured.Unstructured, version kubernetes.SpinnakerVersion) error {
	fake.addSpinnakerVersionAnnotationsMutex.Lock()
	ret, specificReturn := fake.addSpinnakerVersionAnnotationsReturnsOnCall[len(fake.addSpinnakerVersionAnnotationsArgsForCall)]
	fake.addSpinnakerVersionAnnotationsArgsForCall = append(fake.addSpinnakerVersionAnnotationsArgsForCall, struct {
		u       *unstructured.Unstructured
		version kubernetes.SpinnakerVersion
	}{u, version})
	fake.recordInvocation("AddSpinnakerVersionAnnotations", []interface{}{u, version})
	fake.addSpinnakerVersionAnnotationsMutex.Unlock()
	if fake.AddSpinnakerVersionAnnotationsStub != nil {
		return fake.AddSpinnakerVersionAnnotationsStub(u, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addSpinnakerVersionAnnotationsReturns.result1
}

func (fake *FakeController) AddSpinnakerVersionAnnotationsCallCount() int {
	fake.addSpinnakerVersionAnnotationsMutex.RLock()
	defer fake.addSpinnakerVersionAnnotationsMutex.RUnlock()
	return len(fake.addSpinnakerVersionAnnotationsArgsForCall)
}

func (fake *FakeController) AddSpinnakerVersionAnnotationsArgsForCall(i int) (*unstructured.Unstructured, kubernetes.SpinnakerVersion) {
	fake.addSpinnakerVersionAnnotationsMutex.RLock()
	defer fake.addSpinnakerVersionAnnotationsMutex.RUnlock()
	return fake.addSpinnakerVersionAnnotationsArgsForCall[i].u, fake.addSpinnakerVersionAnnotationsArgsForCall[i].version
}

func (fake *FakeController) AddSpinnakerVersionAnnotationsReturns(result1 error) {
	fake.AddSpinnakerVersionAnnotationsStub = nil
	fake.addSpinnakerVersionAnnotationsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerVersionAnnotationsReturnsOnCall(i int, result1 error) {
	fake.AddSpinnakerVersionAnnotationsStub = nil
	if fake.addSpinnakerVersionAnnotationsReturnsOnCall == nil {
		fake.addSpinnakerVersionAnnotationsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpinnakerVersionAnnotationsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerVersionLabels(u *unstructured.Unstructured, version kubernetes.SpinnakerVersion) error {
	fake.addSpinnakerVersionLabelsMutex.Lock()
	ret, specificReturn := fake.addSpinnakerVersionLabelsReturnsOnCall[len(fake.addSpinnakerVersionLabelsArgsForCall)]
	fake.addSpinnakerVersionLabelsArgsForCall = append(fake.addSpinnakerVersionLabelsArgsForCall, struct {
		u       *unstructured.Unstructured
		version kubernetes.SpinnakerVersion
	}{u, version})
	fake.recordInvocation("AddSpinnakerVersionLabels", []interface{}{u, version})
	fake.addSpinnakerVersionLabelsMutex.Unlock()
	if fake.AddSpinnakerVersionLabelsStub != nil {
		return fake.AddSpinnakerVersionLabelsStub(u, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addSpinnakerVersionLabelsReturns.result1
}

func (fake *FakeController) AddSpinnakerVersionLabelsCallCount() int {
	fake.addSpinnakerVersionLabelsMutex.RLock()
	defer fake.addSpinnakerVersionLabelsMutex.RUnlock()
	return len(fake.addSpinnakerVersionLabelsArgsForCall)
}

func (fake *FakeController) AddSpinnakerVersionLabelsArgsForCall(i int) (*unstructured.Unstructured, kubernetes.SpinnakerVersion) {
	fake.addSpinnakerVersionLabelsMutex.RLock()
	defer fake.addSpinnakerVersionLabelsMutex.RUnlock()
	return fake.addSpinnakerVersionLabelsArgsForCall[i].u, fake.addSpinnakerVersionLabelsArgsForCall[i].version
}

func (fake *FakeController) AddSpinnakerVersionLabelsReturns(result1 error) {
	fake.AddSpinnakerVersionLabelsStub = nil
	fake.addSpinnakerVersionLabelsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddSpinnakerVersionLabelsReturnsOnCall(i int, result1 error) {
	fake.AddSpinnakerVersionLabelsStub = nil
	if fake.addSpinnakerVersionLabelsReturnsOnCall == nil {
		fake.addSpinnakerVersionLabelsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpinnakerVersionLabelsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) GetCurrentVersion(ul *unstructured.UnstructuredList, kind string, name string) string {
	fake.getCurrentVersionMutex.Lock()
	ret, specificReturn := fake.getCurrentVersionReturnsOnCall[len(fake.getCurrentVersionArgsForCall)]
	fake.getCurrentVersionArgsForCall = append(fake.getCurrentVersionArgsForCall, struct {
		ul   *unstructured.UnstructuredList
		kind string
		name string
	}{ul, kind, name})
	fake.recordInvocation("GetCurrentVersion", []interface{}{ul, kind, name})
	fake.getCurrentVersionMutex.Unlock()
	if fake.GetCurrentVersionStub != nil {
		return fake.GetCurrentVersionStub(ul, kind, name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getCurrentVersionReturns.result1
}

func (fake *FakeController) GetCurrentVersionCallCount() int {
	fake.getCurrentVersionMutex.RLock()
	defer fake.getCurrentVersionMutex.RUnlock()
	return len(fake.getCurrentVersionArgsForCall)
}

func (fake *FakeController) GetCurrentVersionArgsForCall(i int) (*unstructured.UnstructuredList, string, string) {
	fake.getCurrentVersionMutex.RLock()
	defer fake.getCurrentVersionMutex.RUnlock()
	return fake.getCurrentVersionArgsForCall[i].ul, fake.getCurrentVersionArgsForCall[i].kind, fake.getCurrentVersionArgsForCall[i].name
}

func (fake *FakeController) GetCurrentVersionReturns(result1 string) {
	fake.GetCurrentVersionStub = nil
	fake.getCurrentVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) GetCurrentVersionReturnsOnCall(i int, result1 string) {
	fake.GetCurrentVersionStub = nil
	if fake.getCurrentVersionReturnsOnCall == nil {
		fake.getCurrentVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getCurrentVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) IsVersioned(u *unstructured.Unstructured) bool {
	fake.isVersionedMutex.Lock()
	ret, specificReturn := fake.isVersionedReturnsOnCall[len(fake.isVersionedArgsForCall)]
	fake.isVersionedArgsForCall = append(fake.isVersionedArgsForCall, struct {
		u *unstructured.Unstructured
	}{u})
	fake.recordInvocation("IsVersioned", []interface{}{u})
	fake.isVersionedMutex.Unlock()
	if fake.IsVersionedStub != nil {
		return fake.IsVersionedStub(u)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isVersionedReturns.result1
}

func (fake *FakeController) IsVersionedCallCount() int {
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	return len(fake.isVersionedArgsForCall)
}

func (fake *FakeController) IsVersionedArgsForCall(i int) *unstructured.Unstructured {
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	return fake.isVersionedArgsForCall[i].u
}

func (fake *FakeController) IsVersionedReturns(result1 bool) {
	fake.IsVersionedStub = nil
	fake.isVersionedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsVersionedReturnsOnCall(i int, result1 bool) {
	fake.IsVersionedStub = nil
	if fake.isVersionedReturnsOnCall == nil {
		fake.isVersionedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isVersionedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IncrementVersion(currentVersion string) kubernetes.SpinnakerVersion {
	fake.incrementVersionMutex.Lock()
	ret, specificReturn := fake.incrementVersionReturnsOnCall[len(fake.incrementVersionArgsForCall)]
	fake.incrementVersionArgsForCall = append(fake.incrementVersionArgsForCall, struct {
		currentVersion string
	}{currentVersion})
	fake.recordInvocation("IncrementVersion", []interface{}{currentVersion})
	fake.incrementVersionMutex.Unlock()
	if fake.IncrementVersionStub != nil {
		return fake.IncrementVersionStub(currentVersion)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.incrementVersionReturns.result1
}

func (fake *FakeController) IncrementVersionCallCount() int {
	fake.incrementVersionMutex.RLock()
	defer fake.incrementVersionMutex.RUnlock()
	return len(fake.incrementVersionArgsForCall)
}

func (fake *FakeController) IncrementVersionArgsForCall(i int) string {
	fake.incrementVersionMutex.RLock()
	defer fake.incrementVersionMutex.RUnlock()
	return fake.incrementVersionArgsForCall[i].currentVersion
}

func (fake *FakeController) IncrementVersionReturns(result1 kubernetes.SpinnakerVersion) {
	fake.IncrementVersionStub = nil
	fake.incrementVersionReturns = struct {
		result1 kubernetes.SpinnakerVersion
	}{result1}
}

func (fake *FakeController) IncrementVersionReturnsOnCall(i int, result1 kubernetes.SpinnakerVersion) {
	fake.IncrementVersionStub = nil
	if fake.incrementVersionReturnsOnCall == nil {
		fake.incrementVersionReturnsOnCall = make(map[int]struct {
			result1 kubernetes.SpinnakerVersion
		})
	}
	fake.incrementVersionReturnsOnCall[i] = struct {
		result1 kubernetes.SpinnakerVersion
	}{result1}
}

func (fake *FakeController) VersionVolumes(u *unstructured.Unstructured, requiredArtifacts []clouddriver.TaskCreatedArtifact) error {
	var requiredArtifactsCopy []clouddriver.TaskCreatedArtifact
	if requiredArtifacts != nil {
		requiredArtifactsCopy = make([]clouddriver.TaskCreatedArtifact, len(requiredArtifacts))
		copy(requiredArtifactsCopy, requiredArtifacts)
	}
	fake.versionVolumesMutex.Lock()
	ret, specificReturn := fake.versionVolumesReturnsOnCall[len(fake.versionVolumesArgsForCall)]
	fake.versionVolumesArgsForCall = append(fake.versionVolumesArgsForCall, struct {
		u                 *unstructured.Unstructured
		requiredArtifacts []clouddriver.TaskCreatedArtifact
	}{u, requiredArtifactsCopy})
	fake.recordInvocation("VersionVolumes", []interface{}{u, requiredArtifactsCopy})
	fake.versionVolumesMutex.Unlock()
	if fake.VersionVolumesStub != nil {
		return fake.VersionVolumesStub(u, requiredArtifacts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.versionVolumesReturns.result1
}

func (fake *FakeController) VersionVolumesCallCount() int {
	fake.versionVolumesMutex.RLock()
	defer fake.versionVolumesMutex.RUnlock()
	return len(fake.versionVolumesArgsForCall)
}

func (fake *FakeController) VersionVolumesArgsForCall(i int) (*unstructured.Unstructured, []clouddriver.TaskCreatedArtifact) {
	fake.versionVolumesMutex.RLock()
	defer fake.versionVolumesMutex.RUnlock()
	return fake.versionVolumesArgsForCall[i].u, fake.versionVolumesArgsForCall[i].requiredArtifacts
}

func (fake *FakeController) VersionVolumesReturns(result1 error) {
	fake.VersionVolumesStub = nil
	fake.versionVolumesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) VersionVolumesReturnsOnCall(i int, result1 error) {
	fake.VersionVolumesStub = nil
	if fake.versionVolumesReturnsOnCall == nil {
		fake.versionVolumesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.versionVolumesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	fake.toUnstructuredMutex.RLock()
	defer fake.toUnstructuredMutex.RUnlock()
	fake.addSpinnakerAnnotationsMutex.RLock()
	defer fake.addSpinnakerAnnotationsMutex.RUnlock()
	fake.addSpinnakerLabelsMutex.RLock()
	defer fake.addSpinnakerLabelsMutex.RUnlock()
	fake.sortManifestsMutex.RLock()
	defer fake.sortManifestsMutex.RUnlock()
	fake.addSpinnakerVersionAnnotationsMutex.RLock()
	defer fake.addSpinnakerVersionAnnotationsMutex.RUnlock()
	fake.addSpinnakerVersionLabelsMutex.RLock()
	defer fake.addSpinnakerVersionLabelsMutex.RUnlock()
	fake.getCurrentVersionMutex.RLock()
	defer fake.getCurrentVersionMutex.RUnlock()
	fake.isVersionedMutex.RLock()
	defer fake.isVersionedMutex.RUnlock()
	fake.incrementVersionMutex.RLock()
	defer fake.incrementVersionMutex.RUnlock()
	fake.versionVolumesMutex.RLock()
	defer fake.versionVolumesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kubernetes.Controller = new(FakeController)
