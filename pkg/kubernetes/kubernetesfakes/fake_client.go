// Code generated by counterfeiter. DO NOT EDIT.
package kubernetesfakes

import (
	"sync"

	"github.com/billiford/go-clouddriver/pkg/kubernetes"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
)

type FakeClient struct {
	ApplyStub        func(*unstructured.Unstructured) (kubernetes.Metadata, error)
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
		arg1 *unstructured.Unstructured
	}
	applyReturns struct {
		result1 kubernetes.Metadata
		result2 error
	}
	applyReturnsOnCall map[int]struct {
		result1 kubernetes.Metadata
		result2 error
	}
	ApplyWithNamespaceOverrideStub        func(*unstructured.Unstructured, string) (kubernetes.Metadata, error)
	applyWithNamespaceOverrideMutex       sync.RWMutex
	applyWithNamespaceOverrideArgsForCall []struct {
		arg1 *unstructured.Unstructured
		arg2 string
	}
	applyWithNamespaceOverrideReturns struct {
		result1 kubernetes.Metadata
		result2 error
	}
	applyWithNamespaceOverrideReturnsOnCall map[int]struct {
		result1 kubernetes.Metadata
		result2 error
	}
	GVRForKindStub        func(string) (schema.GroupVersionResource, error)
	gVRForKindMutex       sync.RWMutex
	gVRForKindArgsForCall []struct {
		arg1 string
	}
	gVRForKindReturns struct {
		result1 schema.GroupVersionResource
		result2 error
	}
	gVRForKindReturnsOnCall map[int]struct {
		result1 schema.GroupVersionResource
		result2 error
	}
	GetStub        func(string, string, string) (*unstructured.Unstructured, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	getReturns struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	ListByGVRStub        func(schema.GroupVersionResource, metav1.ListOptions) (*unstructured.UnstructuredList, error)
	listByGVRMutex       sync.RWMutex
	listByGVRArgsForCall []struct {
		arg1 schema.GroupVersionResource
		arg2 metav1.ListOptions
	}
	listByGVRReturns struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}
	listByGVRReturnsOnCall map[int]struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}
	ListResourceStub        func(string, metav1.ListOptions) (*unstructured.UnstructuredList, error)
	listResourceMutex       sync.RWMutex
	listResourceArgsForCall []struct {
		arg1 string
		arg2 metav1.ListOptions
	}
	listResourceReturns struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}
	listResourceReturnsOnCall map[int]struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}
	PatchStub        func(string, string, string, []byte) (kubernetes.Metadata, *unstructured.Unstructured, error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}
	patchReturns struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}
	patchReturnsOnCall map[int]struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}
	PatchUsingStrategyStub        func(string, string, string, []byte, types.PatchType) (kubernetes.Metadata, *unstructured.Unstructured, error)
	patchUsingStrategyMutex       sync.RWMutex
	patchUsingStrategyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 types.PatchType
	}
	patchUsingStrategyReturns struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}
	patchUsingStrategyReturnsOnCall map[int]struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Apply(arg1 *unstructured.Unstructured) (kubernetes.Metadata, error) {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
		arg1 *unstructured.Unstructured
	}{arg1})
	fake.recordInvocation("Apply", []interface{}{arg1})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.applyReturns.result1, fake.applyReturns.result2
}

func (fake *FakeClient) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeClient) ApplyArgsForCall(i int) *unstructured.Unstructured {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return fake.applyArgsForCall[i].arg1
}

func (fake *FakeClient) ApplyReturns(result1 kubernetes.Metadata, result2 error) {
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 kubernetes.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ApplyReturnsOnCall(i int, result1 kubernetes.Metadata, result2 error) {
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Metadata
			result2 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 kubernetes.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ApplyWithNamespaceOverride(arg1 *unstructured.Unstructured, arg2 string) (kubernetes.Metadata, error) {
	fake.applyWithNamespaceOverrideMutex.Lock()
	ret, specificReturn := fake.applyWithNamespaceOverrideReturnsOnCall[len(fake.applyWithNamespaceOverrideArgsForCall)]
	fake.applyWithNamespaceOverrideArgsForCall = append(fake.applyWithNamespaceOverrideArgsForCall, struct {
		arg1 *unstructured.Unstructured
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ApplyWithNamespaceOverride", []interface{}{arg1, arg2})
	fake.applyWithNamespaceOverrideMutex.Unlock()
	if fake.ApplyWithNamespaceOverrideStub != nil {
		return fake.ApplyWithNamespaceOverrideStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.applyWithNamespaceOverrideReturns.result1, fake.applyWithNamespaceOverrideReturns.result2
}

func (fake *FakeClient) ApplyWithNamespaceOverrideCallCount() int {
	fake.applyWithNamespaceOverrideMutex.RLock()
	defer fake.applyWithNamespaceOverrideMutex.RUnlock()
	return len(fake.applyWithNamespaceOverrideArgsForCall)
}

func (fake *FakeClient) ApplyWithNamespaceOverrideArgsForCall(i int) (*unstructured.Unstructured, string) {
	fake.applyWithNamespaceOverrideMutex.RLock()
	defer fake.applyWithNamespaceOverrideMutex.RUnlock()
	return fake.applyWithNamespaceOverrideArgsForCall[i].arg1, fake.applyWithNamespaceOverrideArgsForCall[i].arg2
}

func (fake *FakeClient) ApplyWithNamespaceOverrideReturns(result1 kubernetes.Metadata, result2 error) {
	fake.ApplyWithNamespaceOverrideStub = nil
	fake.applyWithNamespaceOverrideReturns = struct {
		result1 kubernetes.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ApplyWithNamespaceOverrideReturnsOnCall(i int, result1 kubernetes.Metadata, result2 error) {
	fake.ApplyWithNamespaceOverrideStub = nil
	if fake.applyWithNamespaceOverrideReturnsOnCall == nil {
		fake.applyWithNamespaceOverrideReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Metadata
			result2 error
		})
	}
	fake.applyWithNamespaceOverrideReturnsOnCall[i] = struct {
		result1 kubernetes.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GVRForKind(arg1 string) (schema.GroupVersionResource, error) {
	fake.gVRForKindMutex.Lock()
	ret, specificReturn := fake.gVRForKindReturnsOnCall[len(fake.gVRForKindArgsForCall)]
	fake.gVRForKindArgsForCall = append(fake.gVRForKindArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GVRForKind", []interface{}{arg1})
	fake.gVRForKindMutex.Unlock()
	if fake.GVRForKindStub != nil {
		return fake.GVRForKindStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.gVRForKindReturns.result1, fake.gVRForKindReturns.result2
}

func (fake *FakeClient) GVRForKindCallCount() int {
	fake.gVRForKindMutex.RLock()
	defer fake.gVRForKindMutex.RUnlock()
	return len(fake.gVRForKindArgsForCall)
}

func (fake *FakeClient) GVRForKindArgsForCall(i int) string {
	fake.gVRForKindMutex.RLock()
	defer fake.gVRForKindMutex.RUnlock()
	return fake.gVRForKindArgsForCall[i].arg1
}

func (fake *FakeClient) GVRForKindReturns(result1 schema.GroupVersionResource, result2 error) {
	fake.GVRForKindStub = nil
	fake.gVRForKindReturns = struct {
		result1 schema.GroupVersionResource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GVRForKindReturnsOnCall(i int, result1 schema.GroupVersionResource, result2 error) {
	fake.GVRForKindStub = nil
	if fake.gVRForKindReturnsOnCall == nil {
		fake.gVRForKindReturnsOnCall = make(map[int]struct {
			result1 schema.GroupVersionResource
			result2 error
		})
	}
	fake.gVRForKindReturnsOnCall[i] = struct {
		result1 schema.GroupVersionResource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Get(arg1 string, arg2 string, arg3 string) (*unstructured.Unstructured, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeClient) GetArgsForCall(i int) (string, string, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].arg1, fake.getArgsForCall[i].arg2, fake.getArgsForCall[i].arg3
}

func (fake *FakeClient) GetReturns(result1 *unstructured.Unstructured, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetReturnsOnCall(i int, result1 *unstructured.Unstructured, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *unstructured.Unstructured
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListByGVR(arg1 schema.GroupVersionResource, arg2 metav1.ListOptions) (*unstructured.UnstructuredList, error) {
	fake.listByGVRMutex.Lock()
	ret, specificReturn := fake.listByGVRReturnsOnCall[len(fake.listByGVRArgsForCall)]
	fake.listByGVRArgsForCall = append(fake.listByGVRArgsForCall, struct {
		arg1 schema.GroupVersionResource
		arg2 metav1.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListByGVR", []interface{}{arg1, arg2})
	fake.listByGVRMutex.Unlock()
	if fake.ListByGVRStub != nil {
		return fake.ListByGVRStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listByGVRReturns.result1, fake.listByGVRReturns.result2
}

func (fake *FakeClient) ListByGVRCallCount() int {
	fake.listByGVRMutex.RLock()
	defer fake.listByGVRMutex.RUnlock()
	return len(fake.listByGVRArgsForCall)
}

func (fake *FakeClient) ListByGVRArgsForCall(i int) (schema.GroupVersionResource, metav1.ListOptions) {
	fake.listByGVRMutex.RLock()
	defer fake.listByGVRMutex.RUnlock()
	return fake.listByGVRArgsForCall[i].arg1, fake.listByGVRArgsForCall[i].arg2
}

func (fake *FakeClient) ListByGVRReturns(result1 *unstructured.UnstructuredList, result2 error) {
	fake.ListByGVRStub = nil
	fake.listByGVRReturns = struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListByGVRReturnsOnCall(i int, result1 *unstructured.UnstructuredList, result2 error) {
	fake.ListByGVRStub = nil
	if fake.listByGVRReturnsOnCall == nil {
		fake.listByGVRReturnsOnCall = make(map[int]struct {
			result1 *unstructured.UnstructuredList
			result2 error
		})
	}
	fake.listByGVRReturnsOnCall[i] = struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListResource(arg1 string, arg2 metav1.ListOptions) (*unstructured.UnstructuredList, error) {
	fake.listResourceMutex.Lock()
	ret, specificReturn := fake.listResourceReturnsOnCall[len(fake.listResourceArgsForCall)]
	fake.listResourceArgsForCall = append(fake.listResourceArgsForCall, struct {
		arg1 string
		arg2 metav1.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListResource", []interface{}{arg1, arg2})
	fake.listResourceMutex.Unlock()
	if fake.ListResourceStub != nil {
		return fake.ListResourceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listResourceReturns.result1, fake.listResourceReturns.result2
}

func (fake *FakeClient) ListResourceCallCount() int {
	fake.listResourceMutex.RLock()
	defer fake.listResourceMutex.RUnlock()
	return len(fake.listResourceArgsForCall)
}

func (fake *FakeClient) ListResourceArgsForCall(i int) (string, metav1.ListOptions) {
	fake.listResourceMutex.RLock()
	defer fake.listResourceMutex.RUnlock()
	return fake.listResourceArgsForCall[i].arg1, fake.listResourceArgsForCall[i].arg2
}

func (fake *FakeClient) ListResourceReturns(result1 *unstructured.UnstructuredList, result2 error) {
	fake.ListResourceStub = nil
	fake.listResourceReturns = struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListResourceReturnsOnCall(i int, result1 *unstructured.UnstructuredList, result2 error) {
	fake.ListResourceStub = nil
	if fake.listResourceReturnsOnCall == nil {
		fake.listResourceReturnsOnCall = make(map[int]struct {
			result1 *unstructured.UnstructuredList
			result2 error
		})
	}
	fake.listResourceReturnsOnCall[i] = struct {
		result1 *unstructured.UnstructuredList
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Patch(arg1 string, arg2 string, arg3 string, arg4 []byte) (kubernetes.Metadata, *unstructured.Unstructured, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.patchReturns.result1, fake.patchReturns.result2, fake.patchReturns.result3
}

func (fake *FakeClient) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeClient) PatchArgsForCall(i int) (string, string, string, []byte) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return fake.patchArgsForCall[i].arg1, fake.patchArgsForCall[i].arg2, fake.patchArgsForCall[i].arg3, fake.patchArgsForCall[i].arg4
}

func (fake *FakeClient) PatchReturns(result1 kubernetes.Metadata, result2 *unstructured.Unstructured, result3 error) {
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) PatchReturnsOnCall(i int, result1 kubernetes.Metadata, result2 *unstructured.Unstructured, result3 error) {
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Metadata
			result2 *unstructured.Unstructured
			result3 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) PatchUsingStrategy(arg1 string, arg2 string, arg3 string, arg4 []byte, arg5 types.PatchType) (kubernetes.Metadata, *unstructured.Unstructured, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.patchUsingStrategyMutex.Lock()
	ret, specificReturn := fake.patchUsingStrategyReturnsOnCall[len(fake.patchUsingStrategyArgsForCall)]
	fake.patchUsingStrategyArgsForCall = append(fake.patchUsingStrategyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 types.PatchType
	}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.recordInvocation("PatchUsingStrategy", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.patchUsingStrategyMutex.Unlock()
	if fake.PatchUsingStrategyStub != nil {
		return fake.PatchUsingStrategyStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.patchUsingStrategyReturns.result1, fake.patchUsingStrategyReturns.result2, fake.patchUsingStrategyReturns.result3
}

func (fake *FakeClient) PatchUsingStrategyCallCount() int {
	fake.patchUsingStrategyMutex.RLock()
	defer fake.patchUsingStrategyMutex.RUnlock()
	return len(fake.patchUsingStrategyArgsForCall)
}

func (fake *FakeClient) PatchUsingStrategyArgsForCall(i int) (string, string, string, []byte, types.PatchType) {
	fake.patchUsingStrategyMutex.RLock()
	defer fake.patchUsingStrategyMutex.RUnlock()
	return fake.patchUsingStrategyArgsForCall[i].arg1, fake.patchUsingStrategyArgsForCall[i].arg2, fake.patchUsingStrategyArgsForCall[i].arg3, fake.patchUsingStrategyArgsForCall[i].arg4, fake.patchUsingStrategyArgsForCall[i].arg5
}

func (fake *FakeClient) PatchUsingStrategyReturns(result1 kubernetes.Metadata, result2 *unstructured.Unstructured, result3 error) {
	fake.PatchUsingStrategyStub = nil
	fake.patchUsingStrategyReturns = struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) PatchUsingStrategyReturnsOnCall(i int, result1 kubernetes.Metadata, result2 *unstructured.Unstructured, result3 error) {
	fake.PatchUsingStrategyStub = nil
	if fake.patchUsingStrategyReturnsOnCall == nil {
		fake.patchUsingStrategyReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Metadata
			result2 *unstructured.Unstructured
			result3 error
		})
	}
	fake.patchUsingStrategyReturnsOnCall[i] = struct {
		result1 kubernetes.Metadata
		result2 *unstructured.Unstructured
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.applyWithNamespaceOverrideMutex.RLock()
	defer fake.applyWithNamespaceOverrideMutex.RUnlock()
	fake.gVRForKindMutex.RLock()
	defer fake.gVRForKindMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listByGVRMutex.RLock()
	defer fake.listByGVRMutex.RUnlock()
	fake.listResourceMutex.RLock()
	defer fake.listResourceMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.patchUsingStrategyMutex.RLock()
	defer fake.patchUsingStrategyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kubernetes.Client = new(FakeClient)
